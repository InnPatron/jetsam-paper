\documentclass{article}
\usepackage{indentfirst}
\usepackage{ebproof}
\usepackage{amsmath}
\usepackage[
hidelinks,
bookmarksopen
]{hyperref}
\usepackage{listings}

\usepackage{xcolor}
\usepackage{xparse}
\usepackage[style=ACM-Reference-Format,backend=biber]{biblatex}
\usepackage{stmaryrd}

\addbibresource{references.bib}

\NewDocumentCommand{\codeword}{v}{%
	\texttt{\textcolor{blue}{#1}}%
}

\lstset{
	keywordstyle={\bfseries \color{blue}},
	backgroundcolor={\bfseries \color{gray}},
}

	\newcommand{\makedenoteset}[3]{\mathcal{#1} \llbracket #2 \rrbracket && = && \{#3\}}
	\newcommand{\denoteset}[2]{\mathcal{#1} \llbracket #2 \rrbracket}

\begin{document}
	
	\tableofcontents
	\pagebreak
	
	\section{Introduction}
	An early sketch for a specification for Jetsam: a Pyret binding generator for TypeScript code based on augmented simply-typed lambda calculi and source-type indexed logical relations as outlined by \textcite{FFI}.
	
	\section{Core Subset of TypeScript ($TS_{NUM}$)}
	
	A core subset of TypeScript ($TS_{NUM}$) represented as a simply typed lambda calculus augmented with:
	\begin{enumerate}
		\item Double-precision 64-bit binary floats (format IEEE 754)
		\item Float addition (corresponds directly to JS `+' operator)
	\end{enumerate}
	
	\subsection{Terms}
	$t ::=$
	
	\begin{align*}
		float  										&& \text{TS Number} \\
		t_1 + t_2 									&& \text{Addition} \\
		\lambda x\colon T.t_1						&& \text{Abstraction} \\
		t_1 t_2										&& \text{Application}
	\end{align*}


%*********************************************
%*********************************************	
	\subsection{Values}
	v ::=
	\begin{align*}
		float										&& \text{Double-precision 64-bit binary format IEEE 754} \\
		\lambda x\colon T.t							&& \text{Abstraction value}
	\end{align*}
	
	
%*********************************************
%*********************************************	
	\subsection{Types}
	T ::=
	\begin{align*}
		Number												&& \text{Type of floats}\\
		T \rightarrow T										&& \text{Type of functions}
	\end{align*}
	
%*********************************************
%*********************************************
	\subsection{Evaluation}
	
	% E-ADD1
	\begin{prooftree}
		\hypo{t_1 \rightarrow t_1'}
		\infer[right label=@]1[(E-ADD1)]{t_1 + t_2 \rightarrow t_1' + t_2}
	\end{prooftree}\\\\

	%E-ADD2
	\begin{prooftree}
		\hypo{t_2 \rightarrow t_2'}
		\infer[right label=@]1[(E-ADD2)]{v_1 + t_2 \rightarrow v_1 + t_2'}
	\end{prooftree}\\\\

	%E-ADD3
	\begin{prooftree}
		\hypo{float_1 + float_2 = float_3}
		\infer[right label=@]1[(E-ADD3)]{float_1 + float_2 \rightarrow float_3 }
	\end{prooftree}\\\\
	
	%E-APP1
	\begin{prooftree}
		\hypo{t_1 \rightarrow t_1'}
		\infer[right label=@]1[(E-APP1)]{t_1 t_2 \rightarrow t_1' t_2}
	\end{prooftree}\\\\

	%E-APP2
	\begin{prooftree}
		\hypo{t_2 \rightarrow t_2'}
		\infer[right label=@]1[(E-APP2)]{v_1 t_2 \rightarrow v_1 t_2'}
	\end{prooftree}\\\\

	%E-APPABS
	\begin{prooftree}
		\infer[right label=@]0[(E-APPABS)]{
			(\lambda x \colon T.t_1) v_2 \rightarrow [x \mapsto v_2]t_1
		}	
	\end{prooftree}


%*********************************************
%*********************************************
	\subsection{Typing}
	
	% T-NUMBER
	\begin{prooftree}
		\infer[right label=@]0[(T-NUMBER)]{\Gamma \vdash float: Number}
	\end{prooftree}\\\\

	% T-ADD
	\begin{prooftree}
		\hypo{\Gamma \vdash t_1: Number}
		\hypo{\Gamma \vdash t_2: Number}
		\infer[right label=@]2[(T-ADD)]{\Gamma \vdash t_1 + t_2: Number}
	\end{prooftree}\\\\

	% T-VAR
	\begin{prooftree}
		\hypo{x: T \in \Gamma}
		\infer[right label=@]1[(T-VAR)]{\Gamma \vdash x: T}
	\end{prooftree}\\\\

	% T-ABS
	\begin{prooftree}
		\hypo{\Gamma, x: T_1 \vdash t: T_2}
		\infer[right label=@]1[(T-ABS)]{
			\Gamma \vdash \lambda x \colon T_1. t: T_1 \rightarrow T_2
		}
	\end{prooftree}\\\\

	% T-APP
	\begin{prooftree}
		\hypo{\Gamma \vdash t_1: T_1 \rightarrow T_2}
		\hypo{\Gamma \vdash t_2: T_1}
		\infer[right label=@]2[(T-APP)]{
			\Gamma \vdash t_1 t_2: T_2
		}
	\end{prooftree}


%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************
	\section{Core Subset of Pyret ($PY_{NUM}$)}
	A core subset of Pyret ($PY_{NUM}$) represented as a simply typed lambda calculus augmented with:
	\begin{enumerate}
		\item ``Unlimited'' precision rational numbers (as defined in js-number.js \cite{JSNUMBER})
		\item Rational addition (corresponds to the \lstinline{add()} function found in js-number.js \cite{JSNUMBERSSOURCE})
	\end{enumerate}

	\subsection{Terms}
	$t ::=$
	
	\begin{align*}
	rational  									&& \text{Pyret Number} \\
	t_1 + t_2 									&& \text{Addition} \\
	\lambda x \colon T.t_1								&& \text{Abstraction} \\
	t_1 t_2										&& \text{Application}
	\end{align*}
	
	
	%*********************************************
	%*********************************************	
	\subsection{Values}
	v ::=
	\begin{align*}
		rational							&& \text{``Unlimited'' precision rational} \\
		\lambda x \colon T.t						&& \text{Abstraction value}
	\end{align*}
	
	
	%*********************************************
	%*********************************************	
	\subsection{Types}
	T ::=
	\begin{align*}
		Number												&& \text{Type of Pyret rationals}\\
		T \rightarrow T										&& \text{Type of functions}
	\end{align*}
		
	%*********************************************
	%*********************************************
	Evaluation and typing rules are nearly identical to $TS_{NUM}$ (save for a difference in the numeric type) and are omitted for brevity.


%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************	
	\section{$Target Language L$}
	A common target language for $TS_{NUM}$ and $PY_{NUM}$ represented as a simply typed lambda calculus augmented with:
	\begin{enumerate}
		\item ``Unlimited'' precision rational numbers (as found in $PY_{NUM}$)
		\item Rational addition (as found in $PY_{NUM}$)
		\item Double-precision 64-bit binary floats (as found in $TS_{NUM}$)
		\item Float addition (as found in $TS_{NUM}$)
	\end{enumerate}

	\subsection{Terms}
	$t ::=$
	\begin{align*}
		float 		  								&& \text{TS Number} \\
		rational	  								&& \text{Pyret Number} \\
		t_1 + t_2 									&& \text{TS Addition} \\
		t_1 +^{PY} t_2 								&& \text{Pyret Addition} \\
		t_1 t_2 							    	&& \text{Application} \\
		\lambda x\colon T. t					    && \text{Abstraction} \\
	\end{align*}


%*********************************************
%*********************************************
	\subsection{Values}
	v ::=
	\begin{align*}
		float						&& \text{TS Number} \\
		rational					&& \text{Pyret Number}\\
		\lambda x. \tau		    	&& \text{Abstraction} \\
		fail						&& \text{Explicit failure value}
	\end{align*}

	Note that the `fail' value is NOT a `NaN' found with floating point numbers.

%*********************************************
%*********************************************
	\subsection{Types}
	T ::=
	\begin{align*}
		num_f				&& \text{Type of floats}\\
		num_r				&& \text{Type of rationals}\\
		T \rightarrow T		&& \text{Function type}
	\end{align*}
	
	
%*********************************************
%*********************************************	
	\subsection{Evaluation}
	
	% E-ADD1
	\begin{prooftree}
		\hypo{t_1 \rightarrow t_1'}
		\hypo{t_1' \neq fail}
		\infer[right label=@]2[(E-ADD1)]{t_1 + t_2 \rightarrow t_1' + t_2}
	\end{prooftree}\\\\
	
	% E-ADD2
	\begin{prooftree}
		\hypo{t_2 \rightarrow t_2'}
		\hypo{t_2' \neq fail}
		\infer[right label=@]2[(E-ADD2)]{v_1 + t_2 \rightarrow v_1 + t_2'}
	\end{prooftree}\\\\

	% E-ADD3
	\begin{prooftree}
		\hypo{float_1 + float_2 = float_3}
		\infer[right label=@]1[(E-ADD3)]{float_1 + float_2 \rightarrow float_3}
	\end{prooftree}\\\\

	% E-PYADD1
	\begin{prooftree}
		\hypo{t_1 \rightarrow t_1'}
		\hypo{t_1' \neq fail}
		\infer[right label=@]2[(E-PYADD1)]{t_1 +^{PY} t_2 \rightarrow t_1' +^{PY} t_2}
	\end{prooftree}\\\\
	
	% E-PYADD2
	\begin{prooftree}
		\hypo{t_2 \rightarrow t_2'}
		\hypo{t_2' \neq fail}
		\infer[right label=@]2[(E-PYADD2)]{v_1 +^{PY} t_2 \rightarrow v_1 +^{PY} t_2'}
	\end{prooftree}\\\\
	
	% E-PYADD3
	\begin{prooftree}
		\hypo{rational_1 + rational_2 = rational_3}
		\infer[right label=@]1[(E-PYADD3)]{rational_1 +^{PY} rational_2 \rightarrow rational_3}
	\end{prooftree}\\\\
	
	The behavior of terms with `fail' values have been omitted for brevity. Assume evaluating any sub-term to `fail' returns a `fail'. Under the current formulation, no term may evaluate to the explicit `fail' value. The value itself will be used to signal an FFI failure.
	
	Also note that the implementation of `$+^{PY}$' (and all other rational operators provided by js-numbers.js) can handle adding any combination of rational and floating point numbers. For this sketch of a specification, this behavior will be ignored in the evaluation and typing rules. However, this behavior will be considered/used later on when considering the FFI boundary.

%*********************************************
%*********************************************
	\subsection{Typing}
	
	% T-FAIL
	\begin{prooftree}
		\infer[right label=@]0[(T-FAIL)]{\Gamma \vdash fail: T}
	\end{prooftree}\\\\
	
	% T-FLOAT
	\begin{prooftree}
		\infer[right label=@]0[(T-FLOAT)]{\Gamma \vdash float: num_f}
	\end{prooftree}\\\\

	% T-RATIONAL
	\begin{prooftree}
		\infer[right label=@]0[(T-RATIONAL)]{\Gamma \vdash rational: num_r}
	\end{prooftree}\\\\
	
	% T-VAR
	\begin{prooftree}
		\hypo{x: T \in \Gamma}
		\infer[right label=@]1[(T-VAR)]{\Gamma \vdash x: T}
	\end{prooftree}\\\\

	% T-ADD
	\begin{prooftree}
		\hypo{\Gamma \vdash t_1: num_f}
		\hypo{\Gamma \vdash t_2: num_f}
		\infer[right label=@]2[(T-ADD)]{\Gamma \vdash t_1 + t_2: num_f}
	\end{prooftree}\\\\

	% T-PYADD
	\begin{prooftree}
		\hypo{\Gamma \vdash t_1: num_r}
		\hypo{ \Gamma \vdash t_2: num_r}
		\infer[right label=@]2[(T-PYADD)]{\Gamma \vdash t_1 +^{PY} t_2: num_r}
	\end{prooftree}\\\\

	% T-ABS
	\begin{prooftree}
		\hypo{\Gamma, x: T_1 \vdash \tau: T_2}
		\infer[right label=@]1[(T-ABS)]{
			\Gamma \vdash \lambda x:T_1. \tau: T_1 \rightarrow T_2
		}
	\end{prooftree}\\\\
	
	% T-APP
	\begin{prooftree}
		\hypo{\Gamma \vdash t_1: T_1 \rightarrow T_2}
		\hypo{\Gamma \vdash t_2: T_1}
		\infer[right label=@]2[(T-APP)]{
			\Gamma \vdash t_1 t_2: T_2
		}
	\end{prooftree}

%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************	
	\subsection{Compiler $TS_{NUM}$ to Target $L$}

	\subsubsection{Types}
	\begin{align*}
		Number					&& = && num_f\\
		T_1 \rightarrow T_2 	&& = && T_1' \rightarrow T_2'
	\end{align*}
	
%*********************************************
%*********************************************	
	\subsubsection{Terms}
	\begin{align*}
	float: Number							 	&& = && float: num_f\\
	t_1 + t_2: Number					 		&& = && t_1' + t_2': num_f\\
	t_1 t_2: T						 			&& = && t_1' t_2': T'\\
	\lambda x\colon T_1.t: T_1 \rightarrow T_2	&& = && \lambda x: T_1'.t': T_1' \rightarrow T_2'
	\end{align*}
	
	
%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************	
	\subsection{Compiler $PY_{NUM}$ to Target $L$}
	Identical to the compiler of $TS_{NUM}$ to $L$ save for translating the ``$Number$" type to ``$num_r$".

%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************
	\section{The Source-Type Indexed Logical Relationship}
	
	Let $\tau$ be any type from $TS_{NUM}$. Let $\rho$ be any type from $PY_{NUM}$. Let $T$ be any type from either language.\\
	
	Let $\denoteset{V}{T}$ be the set of all possible values of type $T$ as represented in the operational semantics of the target language L.\\
	
	Let $\denoteset{E}{T}$ be the set of all possible terms of type $T$ that evaluate to value $v$ within the operational semantics of $L$ or `fail':
	\[
		\forall t \in \denoteset{E}{T}. (t \Downarrow v \rightarrow v \in \denoteset{V}{T}) \lor (t \Downarrow fail)
	\]

	
	\subparagraph{$TS_{NUM}$}
	\begin{align*}
		\makedenoteset{V}{Number}{n \mid n \text{ is any float}}\\
		\makedenoteset{V}{\tau_1 \rightarrow \tau_2}{
				(\lambda x\colon \tau_1.t)  \mid
				\forall v \in \denoteset{V}{\tau_1}.[x \mapsto v]t \in \denoteset{E}{\tau_2}
		}
	\end{align*}
	
	\subparagraph{$PY_{NUM}$}
	\begin{align*}
		\makedenoteset{V}{Number}{n \mid n \text{ is any rational}}\\
		\makedenoteset{V}{\tau_1 \rightarrow \tau_2}{
			(\lambda x: \rho_1.t) \mid
			\forall v \in \denoteset{V}{\rho_1}.[x \mapsto v]t \in \denoteset{E}{\rho_2}
		}
	\end{align*}
	
	\subsection{Soundness}

	Given a well-typed term, show that it is semantically well-typed (i.e. evaluates to a value of the right semantic type or terminates with `fail'). More formally:\\
	
	\begin{enumerate}
		\item Given a well-typed term $t: \tau$ in $TS_{NUM}$, show:\\
		$\Gamma \vdash t: \tau \implies \forall y \in \denoteset{G}{\Gamma}. y(t) \in \denoteset{E}{\tau}$
		\item Given a well-typed term $t: \rho$ in $PY_{NUM}$, show:\\
		$\Gamma \vdash t: \rho \implies \forall y \in \denoteset{G}{\Gamma}. y(t) \in \denoteset{E}{\rho}$
	\end{enumerate}


	where $\denoteset{G}{\Gamma}$ is the set of all typing contexts that assign the same type as $\Gamma$ to $t$.

	\begin{itemize}
		\item Programs compiled from $PY_{NUM}$ to $L$ will only use $num_r$ and the abstraction types (likewise for $TS_{NUM}$ with $num_f$).
		\item Relying on the above fact, it is trivial to prove that well-typed programs in either language remain well-typed in $L$.
		\item Therefore, a term $t: T$ will be in $\denoteset{E}{T}$ after being compiled to $L$.
	\end{itemize}

	%*********************************************
	%*********************************************
	%*********************************************
	%*********************************************
	%*********************************************
	\section{The Convertibility Relationship}
	
	Let $\tau$ be any type from $TS_{NUM}$. Let $\rho$ be any type from $PY_{NUM}$. Let $T$ be any type from either language.\\
	
	The convertibility of types between $PY_{NUM}$ and $TS_{NUM}$ is written as the symmetric relationship $T_1 \sim T_2$.\\
	
	Two types $\rho$ and $\tau$ can safely be converted between each other iff:
	\begin{itemize}
		\item There exists a translator $C_{\rho \mapsto \tau}$ such that:
		\[
			\forall t \in \denoteset{E}{\rho}. C_{\rho \mapsto \tau}(t) \in \denoteset{E}{\tau}
		\]
		\item There exists a translator $C_{\tau \mapsto \rho}$ such that:
		\[
			\forall t \in \denoteset{E}{\tau}. C_{\tau \mapsto \rho}(t) \in \denoteset{E}{\rho}
		\]
	\end{itemize}
	This is the convertibility soundness lemma. These translators may inject runtime code that performs conversions and these conversions can fail (where it would return the `fail' value).


%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************
\section{Using the Convertibility Relationship Pt. 1}

		
	\printbibliography[heading=bibintoc]
\end{document}