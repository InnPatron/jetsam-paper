\documentclass{article}
\usepackage{indentfirst}
\usepackage{bussproofs}
\usepackage{amsmath}
\usepackage[
hidelinks,
bookmarksopen
]{hyperref}
\usepackage{listings}

\usepackage{xcolor}
\usepackage{xparse}
\usepackage[style=ACM-Reference-Format,backend=biber]{biblatex}
\usepackage{stmaryrd}

\addbibresource{references.bib}

\NewDocumentCommand{\codeword}{v}{%
	\texttt{\textcolor{blue}{#1}}%
}

\lstset{
	keywordstyle={\bfseries \color{blue}},
	backgroundcolor={\bfseries \color{gray}},
}

	\newcommand{\makedenoteset}[3]{\mathcal{#1} \llbracket #2 \rrbracket && = && \{#3\}}
	\newcommand{\denoteset}[2]{\mathcal{#1} \llbracket #2 \rrbracket}
	
\title{Jetsam: A Sound Binding Generator for TypeScript to Pyret}
\author{Alexander Vo}
\date{}

\begin{document}
	\maketitle
	\tableofcontents
	\pagebreak
	
	\section{Introduction}
	This paper presents a prototype specification for the binding generator Jetsam: a program that reads TypeScript code and outputs a wrapper that allows the TypeScript code to be consumed by Pyret. 
	
	Bindings are a form of foreign function interfaces (FFI) where the goal is to provide access to code written in one language to another. They enable interoperability between languages and can greatly broaden the libraries available to a language. This is especially important for Pyret because the ecosystem built around it is tiny in comparison to TypeScript (which in turn has direct access to the JavaScript ecosystem). 
	
	While Pyret already has the facilities to interface with TypeScript and JavaScript code, as of the time of writing, the glue code between Pyret and external libraries must be written manually. This entails writing out type information in a format the Pyret compiler can understand and potentially inserting hand-written conversion routines.
	
	Needless to say, this can be a long, erroneous, and tedious process, and it is the problem that Jetsam seeks to solve. However, in order to generate the correct code, Jetsam needs to be aware of the semantics of Pyret and TypeScript/JavaScript. 
	
	Taking direct inspiration from \textcite{FFI}, this paper uses source-type indexed logical relations as the logical foundation as to what kind of interactions are safe across an FFI boundary.\\
	
	
	This paper is organized in the following way:
	\begin{enumerate}
		\item Define a subset of TypeScript ($TS_{NUM}$) that Jetsam can operate on
		\item Define a subset of Pyret ($PY_{NUM}$) that Jetsam will assume to be the consumer of the generated bindings
		\item Define a common target language/runtime ($L$) that $TS_{NUM}$ and $PY_{NUM}$ will compile into
		\item Define and prove a source-type indexed logical relation that will give a formal relation between types in $TS_{NUM}$ and $PY_{NUM}$ and their representation in $L$
		\item From the source-type indexed logical relation, define and prove a notion of convertibility between $TS_{NUM}$ and $PY_{NUM}$
		\item Present different types of binding styles (considering performance, intent, and ease of use) that utilize convertibility to provide a sound FFI to TypeScript code from Pyret
	\end{enumerate}

	Note that in this paper, the subsets of either language will be \textbf{extremely} constrained.
	
	\section{Core Subset of TypeScript ($TS_{NUM}$)}
	
	A core subset of TypeScript ($TS_{NUM}$) represented as a simply typed lambda calculus augmented with:
	\begin{enumerate}
		\item Double-precision 64-bit binary floats (format IEEE 754)
		\item Float addition (corresponds directly to JS `+' operator)
	\end{enumerate}
	
	\subsection{Terms}
	$t ::=$
	
	\begin{align*}
		x											&& \text{Variable}\\
		float  										&& \text{TS Number} \\
		t_1 + t_2 									&& \text{Addition} \\
		\lambda x\colon T.t_1						&& \text{Abstraction} \\
		t_1 t_2										&& \text{Application}
	\end{align*}


%*********************************************
%*********************************************	
	\subsection{Values}
	v ::=
	\begin{align*}
		float										&& \text{Double-precision 64-bit binary format IEEE 754} \\
		\lambda x\colon T.t							&& \text{Abstraction value}
	\end{align*}
	
	
%*********************************************
%*********************************************	
	\subsection{Types}
	T ::=
	\begin{align*}
		Number												&& \text{Type of floats}\\
		T \rightarrow T										&& \text{Type of functions}
	\end{align*}
	
%*********************************************
%*********************************************
	\subsection{Evaluation}
	
	% E-ADD1
	\begin{prooftree}
		\AxiomC{$t_1 \rightarrow t_1'$}
		\LeftLabel{(E-ADD1)}
		\UnaryInfC{$t_1 + t_2 \rightarrow t_1' + t_2$}
	\end{prooftree}

	%E-ADD2
	\begin{prooftree}
		\AxiomC{$t_2 \rightarrow t_2'$}
		\LeftLabel{(E-ADD1)}
		\UnaryInfC{$v_1 + t_2 \rightarrow v_1 + t_2'$}
	\end{prooftree}

	%E-ADD3
	\begin{prooftree}
		\AxiomC{$float_1 + float_2 = float_3$}
		\LeftLabel{(E-ADD3)}
		\UnaryInfC{$float_1 + float_2 \rightarrow float_3 $}
	\end{prooftree}
	
	%E-APP1
	\begin{prooftree}
		\AxiomC{$t_1 \rightarrow t_1'$}
		\LeftLabel{(E-APP1)}
		\UnaryInfC{$t_1 t_2 \rightarrow t_1' t_2$}
	\end{prooftree}

	%E-APP2
	\begin{prooftree}
		\AxiomC{$t_2 \rightarrow t_2'$}
		\LeftLabel{(E-APP2)}
		\UnaryInfC{$v_1 t_2 \rightarrow v_1 t_2'$}
	\end{prooftree}

	%E-APPABS
	\begin{prooftree}
		\AxiomC{}
		\LeftLabel{(E-APPABS)}
		\UnaryInfC{$(\lambda x \colon T.t_1) v_2 \rightarrow [x \mapsto v_2]t_1$}	
	\end{prooftree}


%*********************************************
%*********************************************
	\subsection{Typing}
	
	% T-NUMBER
	\begin{prooftree}
		\LeftLabel{(T-NUMBER)}
		\AxiomC{}
		\UnaryInfC{$\Gamma \vdash float: Number$}
	\end{prooftree}

	% T-ADD
	\begin{prooftree}
		\AxiomC{$\Gamma \vdash t_1: Number$}
		\AxiomC{$\Gamma \vdash t_2: Number$}
		\LeftLabel{(T-ADD)}
		\BinaryInfC{$\Gamma \vdash t_1 + t_2: Number$}
	\end{prooftree}

	% T-VAR
	\begin{prooftree}
		\AxiomC{$x: T \in \Gamma$}
		\LeftLabel{(T-VAR)}
		\UnaryInfC{$\Gamma \vdash x: T$}
	\end{prooftree}

	% T-ABS
	\begin{prooftree}
		\AxiomC{$\Gamma, x: T_1 \vdash t: T_2$}
		\LeftLabel{(T-ABS)}
		\UnaryInfC{
			$\Gamma \vdash \lambda x \colon T_1. t: T_1 \rightarrow T_2$
		}
	\end{prooftree}

	% T-APP
	\begin{prooftree}
		\AxiomC{$\Gamma \vdash t_1: T_1 \rightarrow T_2$}
		\AxiomC{$\Gamma \vdash t_2: T_1$}
		\LeftLabel{(T-APP)}
		\BinaryInfC{
			$\Gamma \vdash t_1 t_2: T_2$
		}
	\end{prooftree}


%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************
	\section{Core Subset of Pyret ($PY_{NUM}$)}
	A core subset of Pyret ($PY_{NUM}$) represented as a simply typed lambda calculus augmented with:
	\begin{enumerate}
		\item ``Unlimited'' precision rational numbers (as defined in js-number.js \cite{JSNUMBER})
		\item Rational addition (corresponds to the \lstinline{add()} function found in js-number.js \cite{JSNUMBERSSOURCE})
	\end{enumerate}

	\subsection{Terms}
	$t ::=$
	
	\begin{align*}
	x											&& \text{Variable}\\
	rational  									&& \text{Pyret Number} \\
	t_1 + t_2 									&& \text{Addition} \\
	\lambda x \colon T.t_1						&& \text{Abstraction} \\
	t_1 t_2										&& \text{Application}
	\end{align*}
	
	
	%*********************************************
	%*********************************************	
	\subsection{Values}
	v ::=
	\begin{align*}
		rational							&& \text{``Unlimited'' precision rational} \\
		\lambda x \colon T.t						&& \text{Abstraction value}
	\end{align*}
	
	
	%*********************************************
	%*********************************************	
	\subsection{Types}
	T ::=
	\begin{align*}
		Number												&& \text{Type of Pyret rationals}\\
		T \rightarrow T										&& \text{Type of functions}
	\end{align*}
		
	%*********************************************
	%*********************************************
	Evaluation and typing rules are nearly identical to $TS_{NUM}$ (save for a difference in the numeric type) and are omitted for brevity.


%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************	
	\section{Target Language $L$}
	A common target language for $TS_{NUM}$ and $PY_{NUM}$ represented as a simply typed lambda calculus augmented with:
	\begin{enumerate}
		\item ``Unlimited'' precision rational numbers (as found in $PY_{NUM}$)
		\item Rational addition (as found in $PY_{NUM}$)
		\item Double-precision 64-bit binary floats (as found in $TS_{NUM}$)
		\item Float addition (as found in $TS_{NUM}$)
	\end{enumerate}

	\subsection{Terms}
	$t ::=$
	\begin{align*}
		float 		  								&& \text{TS Number} \\
		rational	  								&& \text{Pyret Number} \\
		t_1 + t_2 									&& \text{TS Addition} \\
		t_1 +^{PY} t_2 								&& \text{Pyret Addition} \\
		t_1 t_2 							    	&& \text{Application} \\
		\lambda x\colon T. t					    && \text{Abstraction} \\
	\end{align*}


%*********************************************
%*********************************************
	\subsection{Values}
	v ::=
	\begin{align*}
		float						&& \text{TS Number} \\
		rational					&& \text{Pyret Number}\\
		\lambda x. \tau		    	&& \text{Abstraction} \\
		fail						&& \text{Explicit failure value}
	\end{align*}

	Note that the `fail' value is NOT a `NaN' found with floating point numbers.

%*********************************************
%*********************************************
	\subsection{Types}
	T ::=
	\begin{align*}
		num_f				&& \text{Type of floats}\\
		num_r				&& \text{Type of rationals}\\
		T \rightarrow T		&& \text{Function type}
	\end{align*}
	
	
%*********************************************
%*********************************************	
	\subsection{Evaluation}
	
	% E-ADD1
	\begin{prooftree}
		\AxiomC{$t_1 \rightarrow t_1'$}
		\AxiomC{$t_1' \neq fail$}
		\LeftLabel{(E-ADD1)}
		\BinaryInfC{$t_1 + t_2 \rightarrow t_1' + t_2$}
	\end{prooftree}
	
	% E-ADD2
	\begin{prooftree}
		\AxiomC{$t_2 \rightarrow t_2'$}
		\AxiomC{$t_2' \neq fail$}
		\LeftLabel{(E-ADD2)}
		\BinaryInfC{$v_1 + t_2 \rightarrow v_1 + t_2'$}
	\end{prooftree}

	% E-ADD3
	\begin{prooftree}
		\AxiomC{$float_1 + float_2 = float_3$}
		\LeftLabel{(E-ADD3)}
		\UnaryInfC{$float_1 + float_2 \rightarrow float_3$}
	\end{prooftree}

	% E-PYADD1
	\begin{prooftree}
		\AxiomC{$t_1 \rightarrow t_1'$}
		\AxiomC{$t_1' \neq fail$}
		\LeftLabel{(E-PYADD1)}
		\BinaryInfC{$t_1 +^{PY} t_2 \rightarrow t_1' +^{PY} t_2$}
	\end{prooftree}
	
	% E-PYADD2
	\begin{prooftree}
		\AxiomC{$t_2 \rightarrow t_2'$}
		\AxiomC{$t_2' \neq fail$}
		\LeftLabel{(E-PYADD2)}
		\BinaryInfC{$v_1 +^{PY} t_2 \rightarrow v_1 +^{PY} t_2'$}
	\end{prooftree}
	
	% E-PYADD3
	\begin{prooftree}
		\AxiomC{$rational_1 + rational_2 = rational_3$}
		\LeftLabel{(E-PYADD3)}
		\UnaryInfC{$rational_1 +^{PY} rational_2 \rightarrow rational_3$}
	\end{prooftree}

	%E-APP1
	\begin{prooftree}
		\AxiomC{$t_1 \rightarrow t_1'$}
		\LeftLabel{(E-APP1)}
		\UnaryInfC{$t_1 t_2 \rightarrow t_1' t_2$}
	\end{prooftree}
	
	%E-APP2
	\begin{prooftree}
		\AxiomC{$t_2 \rightarrow t_2'$}
		\LeftLabel{(E-APP2)}
		\UnaryInfC{$v_1 t_2 \rightarrow v_1 t_2'$}
	\end{prooftree}
	
	%E-APPABS
	\begin{prooftree}
		\LeftLabel{(E-APPABS)}
		\AxiomC{}
		\UnaryInfC{
			$(\lambda x \colon T.t_1) v_2 \rightarrow [x \mapsto v_2]t_1$
		}
	\end{prooftree}
	
	\paragraph{}
	The behavior of terms with `fail' values have been omitted for brevity. Assume evaluating any sub-term to `fail' returns a `fail'. Under the current formulation, no term may evaluate to the explicit `fail' value. The value itself will be used to signal an FFI failure.
	
	Also note that the implementation of `$+^{PY}$' (and all other rational operators provided by js-numbers.js) can handle adding any combination of rational and floating point numbers. For this sketch of a specification, this behavior will be ignored in the evaluation and typing rules. However, this behavior will be considered/used later on when considering the FFI boundary.

%*********************************************
%*********************************************
	\subsection{Typing}
	
	% T-FAIL
	\begin{prooftree}
		\LeftLabel{(T-FAIL)}
		\AxiomC{}
		\UnaryInfC{$\Gamma \vdash fail: T$}
	\end{prooftree}
	
	% T-FLOAT
	\begin{prooftree}
		\LeftLabel{(T-FLOAT)}
		\AxiomC{}
		\UnaryInfC{$\Gamma \vdash float: num_f$}
	\end{prooftree}

	% T-RATIONAL
	\begin{prooftree}
		\LeftLabel{(T-RATIONAL)}
		\AxiomC{}
		\UnaryInfC{$\Gamma \vdash rational: num_r$}
	\end{prooftree}
	
	% T-VAR
	\begin{prooftree}
		\AxiomC{$x: T \in \Gamma$}
		\LeftLabel{(T-VAR)}
		\UnaryInfC{$\Gamma \vdash x: T$}
	\end{prooftree}

	% T-ADD
	\begin{prooftree}
		\AxiomC{$\Gamma \vdash t_1: num_f$}
		\AxiomC{$\Gamma \vdash t_2: num_f$}
		\LeftLabel{(T-ADD)}
		\BinaryInfC{$\Gamma \vdash t_1 + t_2: num_f$}
	\end{prooftree}

	% T-PYADD
	\begin{prooftree}
		\AxiomC{$\Gamma \vdash t_1: num_r$}
		\AxiomC{$\Gamma \vdash t_2: num_r$}
		\LeftLabel{(T-PYADD)}
		\BinaryInfC{$\Gamma \vdash t_1 +^{PY} t_2: num_r$}
	\end{prooftree}

	% T-ABS
	\begin{prooftree}
		\AxiomC{$\Gamma, x: T_1 \vdash \tau: T_2$}
		\LeftLabel{(T-ABS)}
		\UnaryInfC{
			$\Gamma \vdash \lambda x:T_1. \tau: T_1 \rightarrow T_2$
		}
	\end{prooftree}
	
	% T-APP
	\begin{prooftree}
		\AxiomC{$\Gamma \vdash t_1: T_1 \rightarrow T_2$}
		\AxiomC{$\Gamma \vdash t_2: T_1$}
		\LeftLabel{(T-APP)}
		\BinaryInfC{
			$\Gamma \vdash t_1 t_2: T_2$
		}
	\end{prooftree}

%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************	
	\subsection{Compiler $TS_{NUM}$ to Target $L$}
	Denoted as $C_{TS \mapsto L}$
	\subsubsection{Types}
	\begin{align*}
		Number					&& = && num_f\\
		T_1 \rightarrow T_2 	&& = && T_1' \rightarrow T_2'
	\end{align*}
	
%*********************************************
%*********************************************	
	\subsubsection{Terms}
	\begin{align*}
	x: T										&& = && x: T'\\
	float: Number							 	&& = && float: num_f\\
	t_1 + t_2: Number					 		&& = && t_1' + t_2': num_f\\
	t_1 t_2: T						 			&& = && t_1' t_2': T'\\
	\lambda x\colon T_1.t: T_1 \rightarrow T_2	&& = && \lambda x: T_1'.t': T_1' \rightarrow T_2'
	\end{align*}
	
	
%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************	
	\subsection{Compiler $PY_{NUM}$ to Target $L$}
		Denoted as $C_{PY \mapsto L}$. Identical to the compiler of $TS_{NUM}$ to $L$ save for translating the ``$Number$" type to ``$num_r$".

%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************
	\section{The Source-Type Indexed Logical Relationship}
	
	Let $\tau$ be any type from $TS_{NUM}$. Let $\rho$ be any type from $PY_{NUM}$. Let $T$ be any type from either language.\\
	
	Let $\denoteset{V}{T}$ be the set of all possible values of type $T$ as represented in the operational semantics of the target language L.\\
	
	Let $\denoteset{E}{T}$ be the set of all possible terms of type $T$ that evaluate to value $v$ within the operational semantics of $L$ or `fail':
	\[
		\forall t \in \denoteset{E}{T}. (t \Downarrow v \implies v \in \denoteset{V}{T}) \lor (t \Downarrow fail)
	\]

	
	\subparagraph{$TS_{NUM}$}
	\begin{align*}
		\makedenoteset{V}{Number}{n \mid n \text{ is any float}}\\
		\makedenoteset{V}{\tau_1 \rightarrow \tau_2}{
				(\lambda x\colon \tau_1.t)  \mid
				\forall v \in \denoteset{V}{\tau_1}.[x \mapsto v]t \in \denoteset{E}{\tau_2}
		}
	\end{align*}
	
	\subparagraph{$PY_{NUM}$}
	\begin{align*}
		\makedenoteset{V}{Number}{n \mid n \text{ is any rational}}\\
		\makedenoteset{V}{\rho_1 \rightarrow \rho_2}{
			(\lambda x: \rho_1.t) \mid
			\forall v \in \denoteset{V}{\rho_1}.[x \mapsto v]t \in \denoteset{E}{\rho_2}
		}
	\end{align*}
	
	\section{Soundness}

	Given a well-typed term in either source language, show that it is semantically well-typed after compiling to $L$ (i.e. evaluates to a value of the right semantic type or terminates with `fail'). More formally:
	
	\begin{enumerate}
		\item Given any well-typed term $t$ in $TS_{NUM}$, show:\\
		$\Gamma \vdash t: \tau \implies \forall y \in \denoteset{G}{\Gamma}. y(C_{TS \mapsto L}(t)) \in \denoteset{E}{\tau}$
		\item Given any well-typed term $t$ in $PY_{NUM}$, show:\\
		$\Gamma \vdash t: \rho \implies \forall y \in \denoteset{G}{\Gamma}. y(C_{PY \mapsto L}(t)) \in \denoteset{E}{\rho}$
	\end{enumerate}


	where $\denoteset{G}{\Gamma}$ is the set of all typing contexts $\Gamma'$ such that given $\Gamma \vdash t: T$ in the source language, assigns the type $T' = C_{source \mapsto L}(T)$ to term $t' = C_{source \mapsto L}(t)$.
	
	\subsection{$TS_{NUM}$}
	
	% TS_NUM Number Soundness
	\paragraph{(Compatibility $Number$).}
	$\Gamma \vdash t: Number \implies \forall y \in \denoteset{G}{\Gamma}. y(C_{TS \mapsto L}(t)) \in \denoteset{E}{Number}$
	
	Proof by induction on typing derivations:
	
	\begin{itemize}
		% T-NUMBER
		\item Case T-NUMBER: $t = float$:
		\begin{enumerate}
			\item Let $t' = C_{TS \mapsto L}(t) = float \in \denoteset{V}{Number}$
			\item $t' \in \denoteset{V}{Number} \implies t' \in \denoteset{E}{Number}$ by definition
		\end{enumerate}
		
		%T-VAR
		\item Case T-VAR: $t = x$; $x: Number \in Gamma$
		\begin{enumerate}
			\item Let $t' = C_{TS \mapsto L}(t) = x$
			\item $x$ is a value, $x: Number \implies x = float \implies t \in \denoteset{E}{Number}$ by definition
		\end{enumerate}
	
		% T-ADD
		\item Case T-ADD: $t = t_1 + t_2$; $\Gamma \vdash t_1: Number$; $\Gamma \vdash t_2: Number$
		\begin{enumerate}
			\item Let $t'_1 = C_{TS \mapsto L}(t_1)$, $t'_2 = C_{TS \mapsto L}(t_2)$
			\item Let $t' = C_{TS \mapsto L}(t) = C_{TS \mapsto L}(t_1) + C_{TS \mapsto L}(t_2) = t'_1 + t'_2$
			\item By the IH, $t'_1 \in \denoteset{E}{Number}$ and $t'_2 \in \denoteset{E}{Number}$
			\item If $(t'_1 \Downarrow fail)$ or $(t'_2 \Downarrow fail)$, then by the convention noted in $L$'s evaluation rules:\\
				$t' \Downarrow fail \implies t' \in \denoteset{E}{Number}$
			\item If $(t'_1 \Downarrow float_1)$ and $(t'_2 \Downarrow float_2)$:\\
				$t' \Downarrow float \implies t' \in \denoteset{E}{Number}$
		\end{enumerate}
	
		%T-APP
		\item Case T-APP: $t = t_1 t_2$; $\Gamma \vdash t_1: T_1 \rightarrow Number$; $\Gamma \vdash t_2: T_1$
		\begin{enumerate}
			\item Let $t'_1 = C_{TS \mapsto L}(t_1)$, $t'_2 = C_{TS \mapsto L}(t_2)$
			\item Let $t' = C_{TS \mapsto L}(t) = C_{TS \mapsto L}(t_1) C_{TS \mapsto L}(t_2) = t'_1 t'_2$
			\item By the IH, $t'_1 \in \denoteset{E}{T_1 \rightarrow Number}$ and $t'_2 \in \denoteset{E}{T_1}$
			\item If $(t'_1 \Downarrow fail)$ or $(t'_2 \Downarrow fail)$, then by the convention noted in $L$'s evaluation rules:\\
			$t' \Downarrow fail \implies t' \in \denoteset{E}{Number}$
			\item If $(t'_1 \Downarrow (\lambda x: T_1'.t_3))$ and $(t'_2 \Downarrow v \in \denoteset{V}{T_1}, v \neq fail)$:\\
			\begin{enumerate}
				\item $[x \mapsto v]t_3 \Downarrow float \implies t' \Downarrow float \implies t' \in \denoteset{E}{Number}$
				\item $[x \mapsto v]t_3 \Downarrow fail \implies t' \Downarrow fail \implies t' \in \denoteset{E}{Number}$
			\end{enumerate}

		\end{enumerate}
	\end{itemize}

	% TS_NUM Abstraction Soundness
	\paragraph{(Compatibility $Abstraction$).}
	$\Gamma \vdash t: T_1 \rightarrow T_2 \implies \forall y \in \denoteset{G}{\Gamma}. y(C_{TS \mapsto L}(t)) \in \denoteset{E}{T_1 \rightarrow T_2}$

	Proof by induction on typing derivations:
	
	\begin{itemize}
		\item Case T-ABS: $t = (\lambda x: T_1.t_2)$; $\Gamma, x: T_1 \vdash t_2: T_2$
		\begin{enumerate}
			\item Let $t' = C_{TS \mapsto L}(t) = (\lambda x: T'_1.t'_2)$
			\item Let $v \in \denoteset{V}{T_1}, v \neq fail$
			\item By the IH, $t'_2 \in \denoteset{E}{T_2}$
			\item $v \neq fail$ because per the evaluation conventions for $L$, $x$ could only be bound to a value during application. If the argument evaluated to $fail$, substitution will never occur.
			\item $[x \mapsto v]t'_2 \Downarrow v' \in \denoteset{V}{T_2} \implies t' \in \denoteset{E}{T_1 \rightarrow T_2}$
		\end{enumerate}
	\end{itemize}

	\subsection{$PY_{NUM}$}
	
	The proof is identical to $TS_{NUM}$ save for using the $rational$ values and type $num_r$ instead of $float$ values and type $num_f$.

	%*********************************************
	%*********************************************
	%*********************************************
	%*********************************************
	%*********************************************
	\section{The Convertibility Relationship}
	
	Let $\tau$ be any type from $TS_{NUM}$. Let $\rho$ be any type from $PY_{NUM}$. Let $T$ be any type from either language.\\
	
	The convertibility of types between $PY_{NUM}$ and $TS_{NUM}$ is written as the symmetric relationship $T_1 \sim T_2$.\\
	
	Two types $\rho$ and $\tau$ can safely be converted between each other iff:
	\begin{itemize}
		\item There exists a translator $C_{\rho \mapsto \tau}$ such that:
		\[
			\forall t \in \denoteset{E}{\rho}. C_{\rho \mapsto \tau}(t) \in \denoteset{E}{\tau}
		\]
		\item There exists a translator $C_{\tau \mapsto \rho}$ such that:
		\[
			\forall t \in \denoteset{E}{\tau}. C_{\tau \mapsto \rho}(t) \in \denoteset{E}{\rho}
		\]
	\end{itemize}
	This is the convertibility soundness lemma. These translators may inject runtime code that performs conversions and these conversions can fail (where it would return the `fail' value).


%*********************************************
%*********************************************
%*********************************************
%*********************************************
%*********************************************
\section{Using the Convertibility Relationship Pt. 1}

		
	\printbibliography[heading=bibintoc]
\end{document}
